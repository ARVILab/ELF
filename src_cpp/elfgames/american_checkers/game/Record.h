#pragma once

#include <fstream>
#include <iostream>
#include <mutex>
#include <string>
#include <vector>

#include <nlohmann/json.hpp>

// game
#include "../common/ModelPair.h"
#include "GameBoard.h"

using json = nlohmann::json;

struct GameCoordRecord {
  unsigned char prob[TOTAL_NUM_ACTIONS];
};


struct GameMsgResult {
  int   num_move = 0;
  float reward = 0.0;
  bool  draw = false;
  
  // Whether this replay is generated by mutliple models.
  std::vector<int64_t> using_models;
  std::string content;
  std::vector<GameCoordRecord> policies;
  std::vector<float> values;

  std::string info() const {
    std::stringstream ss;
    ss << "\nGameMsgResult::info()\t[num_move=" << num_move << "]";
    ss << "[models=";
    for (const auto& i : using_models)
      ss << i << ", ";
    ss << "]";
    ss << "[reward=" << reward << "]"
       << "[len(content)=" << content.size() << "]";
    return ss.str();
  }

  void setJsonFields(json& j) const {
    JSON_SAVE(j, num_move);
    JSON_SAVE(j, reward);
    JSON_SAVE(j, using_models);
    JSON_SAVE(j, content);

    for (size_t i = 0; i < policies.size(); i++) {
      json j1;
      for (unsigned char c : policies[i].prob) {
        j1.push_back(c);
      }
      j["policies"].push_back(j1);
    }
    JSON_SAVE(j, values);
  }

  static GameMsgResult createFromJson(const json& j) {
    GameMsgResult res;

    JSON_LOAD(res, j, num_move);
    JSON_LOAD(res, j, reward);
    JSON_LOAD(res, j, content);
    JSON_LOAD_VEC_OPTIONAL(res, j, using_models);
    JSON_LOAD_VEC(res, j, values);

    if (j.find("policies") != j.end()) {
      size_t num_policies = j["policies"].size();
      for (size_t i = 0; i < num_policies; i++) {
        json j1 = j["policies"][i];
        res.policies.emplace_back();
        for (size_t k = 0; k < j1.size(); k++) {
          res.policies.back().prob[k] = j1[k];
        }
      }
    }
    return res;
  }
};

/* 
  One game record
*/
struct GameRecord {
  MsgRequest request;
  GameMsgResult result;

  uint64_t timestamp = 0;
  uint64_t thread_id = 0;
  int   seq = 0;
  float pri = 0.0;
  bool  offline = false;

  std::string info() const {
    std::stringstream ss;
    ss << "\nGameRecord::info()\t[t=" << timestamp << "]"
        << "[id=" << thread_id << "]" 
        << "[seq=" << seq << "]" 
        << "[pri=" << pri << "]" 
        << "[offline=" << offline << "]";
    ss << request.info();
    ss << result.info();
    return ss.str();
  }

  void setJsonFields(json& j) const {
    JSON_SAVE_OBJ(j, request);
    JSON_SAVE_OBJ(j, result);
    JSON_SAVE(j, timestamp);
    JSON_SAVE(j, thread_id);
    JSON_SAVE(j, seq);
    JSON_SAVE(j, pri);
    JSON_SAVE(j, offline);
  }

  static GameRecord createFromJson(const json& j) {
    GameRecord r;

    JSON_LOAD_OBJ(r, j, request);
    JSON_LOAD_OBJ(r, j, result);
    JSON_LOAD(r, j, timestamp);
    JSON_LOAD(r, j, thread_id);
    JSON_LOAD(r, j, seq);
    JSON_LOAD(r, j, pri);
    JSON_LOAD_OPTIONAL(r, j, offline);
    return r;
  }

  // Extra serialization.
  static std::vector<GameRecord> createBatchFromJson(const std::string& json_str) {
    return createBatchFromJson(json::parse(json_str));
  }

  static std::vector<GameRecord> createBatchFromJson(const json& j) {
    std::vector<GameRecord> records;
    for (size_t i = 0; i < j.size(); ++i) {
      try {
        records.push_back(createFromJson(j[i]));
      } catch (...) {
      }
    }
    return records;
  }

  static bool loadContent(const std::string& f, std::string* msg) {
    try {
      std::ifstream iFile(f.c_str());
      iFile.seekg(0, std::ios::end);
      size_t size = iFile.tellg();
      msg->resize(size, ' ');
      iFile.seekg(0);
      iFile.read(&(*msg)[0], size);
      return true;
    } catch (...) {
      return false;
    }
  }

  static bool loadBatchFromJsonFile(
      const std::string& f,
      std::vector<GameRecord>* records) {
    assert(records != nullptr);

    try {
      std::string buffer;
      if (!loadContent(f, &buffer)) {
        return false;
      }
      *records = createBatchFromJson(buffer);
      return true;
    } catch (...) {
      return false;
    }
  }

  static std::string dumpBatchJsonString(
      std::vector<GameRecord>::const_iterator b,
      std::vector<GameRecord>::const_iterator e) {
    json j;
    for (auto it = b; it != e; ++it) {
      json j1;
      it->setJsonFields(j1);
      j.push_back(j1);
    }
    return j.dump();
  }
};

/* 
  Collect game records to send it to server
*/
struct GameRecords {
  std::string identity;
  std::unordered_map<int, ThreadState> states;
  std::vector<GameRecord> records;

  GameRecords() { 
  }

  GameRecords(const std::string& id) : identity(id) {
  }

  void clear() {
    states.clear();
    records.clear();
  }

  void addRecord(GameRecord&& r) {
    records.emplace_back(r);
  }

  bool isRecordEmpty() const {
    return records.empty();
  }

  void updateState(const ThreadState& ts) {
    states[ts.thread_id] = ts;
  }

  void setJsonFields(json& j) const {
    JSON_SAVE(j, identity);
    for (const auto& t : states) {
      json jj;
      t.second.setJsonFields(jj);
      j["states"].push_back(jj);
    }

    for (const GameRecord& r : records) {
      json j1;
      r.setJsonFields(j1);
      j["records"].push_back(j1);
    }
  }

  static GameRecords createFromJson(const json& j) {
    GameRecords rs;

    JSON_LOAD(rs, j, identity);
    if (j.find("states") != j.end()) {
      for (size_t i = 0; i < j["states"].size(); ++i) {
        ThreadState t = ThreadState::createFromJson(j["states"][i]);
        rs.states[t.thread_id] = t;
      }
    }

    if (j.find("records") != j.end()) {
      for (size_t i = 0; i < j["records"].size(); ++i) {
        rs.records.push_back(GameRecord::createFromJson(j["records"][i]));
      }
    }
    return rs;
  }

  std::string dumpJsonString() const {
    json j;

    setJsonFields(j);
    return j.dump();
  }

  static GameRecords createFromJsonString(const std::string& s) {   
    json j = json::parse(s);

    if (j.find("identity") == j.end()) {
      // This is a vector<GameRecords>
      GameRecords rs("");
      rs.records = GameRecord::createBatchFromJson(s);
      return rs;
    } else {
      return createFromJson(j);
    }
  }
};
